#include "dartt_init.h"
#include <cstdio>

Serial serial;
bool use_udp = false;
UdpState udp_state = { TCS_SOCKET_INVALID, "192.168.1.100", 5000, false };

 #define NUM_BYTES_COBS_OVERHEAD	2	//we have to tell dartt our serial buffers are smaller than they are, so the COBS layer has room to operate. This allows for functional multiple message handling with write_multi and read_multi for large configs

unsigned char tx_mem[SERIAL_BUFFER_SIZE] = {};
unsigned char rx_dartt_mem[SERIAL_BUFFER_SIZE] = {};
unsigned char rx_cobs_mem[SERIAL_BUFFER_SIZE] = {};


int tx_blocking(unsigned char addr, dartt_buffer_t * b, uint32_t timeout)
{
	cobs_buf_t cb = {
		.buf = b->buf,
		.size = b->size,
		.length = b->len,
		.encoded_state = COBS_DECODED
	};
	int rc = cobs_encode_single_buffer(&cb);
	if (rc != 0)
	{
		return rc;
	}
	if (use_udp)
	{
		if (!udp_state.connected)
			return -1;
		size_t bytes_sent = 0;
		TcsResult res = tcs_send(udp_state.socket, cb.buf, cb.length, TCS_FLAG_NONE, &bytes_sent);
		rc = (res == TCS_SUCCESS && bytes_sent == cb.length) ? (int)cb.length : -1;
	}
	else
	{
		rc = serial.write(cb.buf, (int)cb.length);
	}
	if(rc == (int)cb.length)
	{
		return DARTT_PROTOCOL_SUCCESS;
	}
	else
	{
		return -1;
	}
}

int rx_blocking(dartt_buffer_t * buf, uint32_t timeout)
{
	cobs_buf_t cb_enc =
	{
		.buf = rx_cobs_mem,
		.size = sizeof(rx_cobs_mem),
		.length = 0
	};

	int rc;
	if (use_udp)
	{
		if (!udp_state.connected)
			return -1;
		struct TcsAddress src;
		size_t bytes_received = 0;
		tcs_opt_receive_timeout_set(udp_state.socket, timeout);
		TcsResult res = tcs_receive_from(udp_state.socket, cb_enc.buf, cb_enc.size, TCS_FLAG_NONE, &src, &bytes_received);
		if (res == TCS_SUCCESS)
		{
			rc = (int)bytes_received;
		}
		else
			rc = -2;
	}
	else
	{
		rc = serial.read_until_delimiter(cb_enc.buf, cb_enc.size, 0, timeout);
	}

	if (rc >= 0)
	{
		cb_enc.length = rc;	//load encoded length (raw buffer)
	}
	else if (rc == -2)
	{
		return -7;
	}
	else
	{
		return -1;
	}

	cobs_buf_t cb_dec =
	{
		.buf = buf->buf,
		.size = buf->size,
		.length = 0
	};
	rc = cobs_decode_double_buffer(&cb_enc, &cb_dec);
	buf->len = cb_dec.length;	//critical - we are aliasing this read buffer in sync, but must update the length to the cobs decoded value

	if (rc != COBS_SUCCESS)
	{
		return rc;
	}
	else
	{
		return DARTT_PROTOCOL_SUCCESS;
	}
    
}

void init_ds(dartt_sync_t * ds)
{
	ds->address = 0;	//must be mapped
	ds->ctl_base = {};	//must be assigned
	ds->periph_base = {};	//must be assigned
	ds->msg_type = TYPE_SERIAL_MESSAGE;
	ds->tx_buf.buf = tx_mem;
	ds->tx_buf.size = sizeof(tx_mem) - NUM_BYTES_COBS_OVERHEAD;		//DO NOT CHANGE. This is for a good reason. See above note
	ds->tx_buf.len = 0;
	ds->rx_buf.buf = rx_dartt_mem;
	ds->rx_buf.size = sizeof(rx_dartt_mem) - NUM_BYTES_COBS_OVERHEAD;	//DO NOT CHANGE. This is for a good reason. See above note
	ds->rx_buf.len = 0;
	ds->blocking_tx_callback = &tx_blocking;
	ds->blocking_rx_callback = &rx_blocking;
	ds->timeout_ms = 10;
}

bool udp_connect(UdpState* state)
{
	if (state->connected)
		udp_disconnect(state);

	state->socket = TCS_SOCKET_INVALID;
	TcsResult res = tcs_socket_preset(&state->socket, TCS_PRESET_UDP_IP4);
	if (res != TCS_SUCCESS)
	{
		printf("UDP: failed to create socket (%d)\n", res);
		return false;
	}

	// Resolve IP string to TcsAddress, then connect
	struct TcsAddress remote_addr = TCS_ADDRESS_NONE;
	size_t addr_count = 0;
	res = tcs_address_resolve(state->ip, TCS_AF_IP4, &remote_addr, 1, &addr_count);
	if (res != TCS_SUCCESS || addr_count == 0)
	{
		printf("UDP: failed to resolve address '%s' (%d)\n", state->ip, res);
		tcs_close(&state->socket);
		return false;
	}
	remote_addr.data.ip4.port = state->port;

	res = tcs_connect(state->socket, &remote_addr);
	if (res != TCS_SUCCESS)
	{
		printf("UDP: failed to connect to %s:%u (%d)\n", state->ip, state->port, res);
		tcs_close(&state->socket);
		return false;
	}

	state->connected = true;
	printf("UDP: connected to %s:%u\n", state->ip, state->port);
	return true;
}

void udp_disconnect(UdpState* state)
{
	if (state->socket != TCS_SOCKET_INVALID)
	{
		tcs_close(&state->socket);
	}
	state->connected = false;
	printf("UDP: disconnected\n");
}